

....................................DAY-4...........................................................................................





......................................................DAY-5..................................................................................

Que.1 - Searching a Number 

Given an integer k and array arr. Your task is to return the position of the first occurrence of k in the given array and if element k is not present in the array then return -1.

Note: 1-based indexing is followed here.

Examples:

Input: k = 16 , arr = [9, 7, 16, 16, 4]
Output: 3
Explanation: The value 16 is found in the given array at positions 3 and 4, with position 3 being the first occurrence.
Input: k=98 , arr = [1, 22, 57, 47, 34, 18, 66]
Output: -1
Explanation: k = 98 isn't found in the given array.
Expected Time Complexity: O(n)
Expected Auxiliary Space: O(1)

Constraints:
1 <= arr.size <= 106
1 <= arr[i] <= 109
1 <= k <= 106

Code:--


#include <iostream>
#include <vector>
using namespace std;

int findFirstOccurrence(int k, const vector<int>& arr) {
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == k) {
            return i + 1; // Return 1-based index
        }
    }
    return -1; // Return -1 if k is not found
}

int main() {
    // Example 1
    int k1 = 16;
    vector<int> arr1 = {9, 7, 16, 16, 4};
    cout << findFirstOccurrence(k1, arr1) << endl; // Output: 3

    // Example 2
    int k2 = 98;
    vector<int> arr2 = {1, 22, 57, 47, 34, 18, 66};
    cout << findFirstOccurrence(k2, arr2) << endl; // Output: -1

    return 0;
}

Que2:-- Sorted Array search.

Code:
#include <iostream>
#include <vector>
using namespace std;

int findFirstOccurrence(int k, const vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    int result = -1; // Store the index of the first occurrence

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == k) {
            result = mid + 1; // Store the 1-based index
            right = mid - 1;  // Move left to find the first occurrence
        } else if (arr[mid] < k) {
            left = mid + 1; // Search in the right half
        } else {
            right = mid - 1; // Search in the left half
        }
    }

    return result; // Returns -1 if not found
}

int main() {
    // Example 1
    int k1 = 16;
    vector<int> arr1 = {4, 7, 16, 16, 20, 25};
    cout << findFirstOccurrence(k1, arr1) << endl; // Output: 3

    // Example 2
    int k2 = 98;
    vector<int> arr2 = {1, 22, 57, 57, 66, 99};
    cout << findFirstOccurrence(k2, arr2) << endl; // Output: -1

    return 0;
}

Que 3..
Find target indeces after sorting on leetcode.


You are given a 0-indexed integer array nums and a target element target.

A target index is an index i such that nums[i] == target.

Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.

 

Example 1:

Input: nums = [1,2,5,2,3], target = 2
Output: [1,2]
Explanation: After sorting, nums is [1,2,2,3,5].
The indices where nums[i] == 2 are 1 and 2.
Example 2:

Input: nums = [1,2,5,2,3], target = 3
Output: [3]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 3 is 3.
Example 3:

Input: nums = [1,2,5,2,3], target = 5
Output: [4]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 5 is 4.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i], target <= 100


Code:---

#include <iostream>
#include <vector>
#include <algorithm> // For std::sort

using namespace std;

vector<int> targetIndices(vector<int>& nums, int target) {
    // Step 1: Sort the array in non-decreasing order
    sort(nums.begin(), nums.end());
    
    vector<int> result;
    // Step 2: Collect indices of elements equal to the target
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == target) {
            result.push_back(i); // Append the index
        }
    }
    return result;
}

int main() {
    // Example 1
    vector<int> nums1 = {1, 2, 5, 2, 3};
    int target1 = 2;
    vector<int> result1 = targetIndices(nums1, target1);
    for (int idx : result1) cout << idx << " "; // Output: 1 2
    cout << endl;

    // Example 2
    vector<int> nums2 = {1, 2, 5, 2, 3};
    int target2 = 3;
    vector<int> result2 = targetIndices(nums2, target2);
    for (int idx : result2) cout << idx << " "; // Output: 3
    cout << endl;

    // Example 3
    vector<int> nums3 = {1, 2, 5, 2, 3};
    int target3 = 5;
    vector<int> result3 = targetIndices(nums3, target3);
    for (int idx : result3) cout << idx << " "; // Output: 4
    cout << endl;

    return 0;
}

Que 4:-- Valid parenthesis on leet code.

Code:
#include <iostream>
#include <stack>
#include <unordered_map>
using namespace std;

bool isValid(string s) {
    stack<char> stack;
    // Mapping of closing brackets to opening brackets
    unordered_map<char, char> mapping = {{')', '('}, {'}', '{'}, {']', '['}};
    
    for (char c : s) {
        if (mapping.count(c)) { // If it is a closing bracket
            // Get the top element of the stack, or a dummy value if the stack is empty
            char topElement = stack.empty() ? '#' : stack.top();
            stack.pop();
            // If the mapping does not match, return false
            if (mapping[c] != topElement) {
                return false;
            }
        } else {
            // It's an opening bracket, push onto the stack
            stack.push(c);
        }
    }
    
    // If the stack is empty, the parentheses are valid
    return stack.empty();
}

int main() {
    string s = "{[()]}";
    if (isValid(s)) {
        cout << "Valid" << endl;
    } else {
        cout << "Invalid" << endl;
    }
    return 0;
}


Que 5:-

Searching element from roateted Array on leet code .

#include <iostream>
#include <vector>
using namespace std;

int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        // Check if the mid element is the target
        if (nums[mid] == target) {
            return mid;
        }

        // Check if the left half is sorted
        if (nums[left] <= nums[mid]) {
            // Target lies in the sorted left half
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else { // Target is in the unsorted right half
                left = mid + 1;
            }
        } 
        // Otherwise, the right half is sorted
        else {
            // Target lies in the sorted right half
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else { // Target is in the unsorted left half
                right = mid - 1;
            }
        }
    }

    // If the element is not found
    return -1;
}

int main() {
    vector<int> nums = {4, 5, 6, 7, 0, 1, 2};
    int target = 0;

    int result = search(nums, target);
    if (result != -1) {
        cout << "Element found at index: " << result << endl;
    } else {
        cout << "Element not found" << endl;
    }

    return 0;
}


..............................DAY-6.............................................................................................

QUE.1:- Pair sum closet to 0 ( GEEks for GEEKs).

Code :

#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

pair<int, int> findClosestPair(vector<int>& nums) {
    // Sort the array
    sort(nums.begin(), nums.end());
    
    int left = 0, right = nums.size() - 1;
    int closestSum = INT_MAX; // Initialize to a large value
    pair<int, int> result;

    while (left < right) {
        int sum = nums[left] + nums[right];

        // Update the closest sum and result pair
        if (abs(sum) < abs(closestSum)) {
            closestSum = sum;
            result = {nums[left], nums[right]};
        }

        // Move the pointers based on the sum
        if (sum < 0) {
            left++; // Increase the sum
        } else {
            right--; // Decrease the sum
        }
    }

    return result;
}

int main() {
    vector<int> nums = {-1, 2, -3, 4, -2};
    pair<int, int> result = findClosestPair(nums);

    cout << "Pair closest to 0: (" << result.first << ", " << result.second << ")" << endl;
    return 0;
}


QU.2:--  Search in 2d Matrix on (Leet code ).


#include <iostream>
#include <vector>
using namespace std;

bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.empty() || matrix[0].empty()) return false;

    int m = matrix.size();
    int n = matrix[0].size();
    int left = 0, right = m * n - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int midValue = matrix[mid / n][mid % n]; // Convert 1D index to 2D index

        if (midValue == target) {
            return true;
        } else if (midValue < target) {
            left = mid + 1; // Search right half
        } else {
            right = mid - 1; // Search left half
        }
    }

    return false;
}

int main() {
    vector<vector<int>> matrix = {
        {1, 3, 5, 7},
        {10, 11, 16, 20},
        {23, 30, 34, 60}
    };
    int target = 3;

    if (searchMatrix(matrix, target)) {
        cout << "Target found in the matrix!" << endl;
    } else {
        cout << "Target not found in the matrix." << endl;
    }

    return 0;
}


QUE.3:-- Find the Kth smallest sum of matrix with sorted row on (leet code).

Code:


#include <iostream>
#include <vector>
#include <queue>
#include <functional>
using namespace std;

struct Element {
    int sum;
    vector<int> indices; // Indices of elements contributing to the sum
    
    Element(int sum, vector<int> indices) : sum(sum), indices(indices) {}
    
    bool operator>(const Element& other) const {
        return sum > other.sum; // Min-heap based on sum
    }
};

int kthSmallestSum(vector<vector<int>>& matrix, int k) {
    int m = matrix.size(), n = matrix[0].size();
    
    // Min-heap to store the sum and indices of the elements contributing to that sum
    priority_queue<Element, vector<Element>, greater<Element>> minHeap;

    // Initialize the heap with the sum of the first element in each row
    vector<int> indices(m, 0); // Indices pointing to the first element in each row
    int initialSum = 0;
    for (int i = 0; i < m; ++i) {
        initialSum += matrix[i][0];
    }
    
    minHeap.push(Element(initialSum, indices));
    
    // Pop k times to find the kth smallest sum
    for (int count = 0; count < k; ++count) {
        Element current = minHeap.top();
        minHeap.pop();
        
        // If we have already popped k sums, return the current sum
        if (count == k - 1) {
            return current.sum;
        }
        
        // Generate next sums by incrementing indices in each row
        for (int i = 0; i < m; ++i) {
            if (current.indices[i] + 1 < n) {
                vector<int> newIndices = current.indices;
                newIndices[i]++;
                int newSum = current.sum - matrix[i][current.indices[i]] + matrix[i][newIndices[i]];
                minHeap.push(Element(newSum, newIndices));
            }
        }
    }
    
    return -1; // If Kth smallest sum doesn't exist (shouldn't happen in valid cases)
}

int main() {
    vector<vector<int>> matrix = {{1, 3, 11}, {2, 4, 6}, {1, 2, 3}};
    int k = 5;

    cout << "The " << k << "th smallest sum is: " << kthSmallestSum(matrix, k) << endl;

    return 0;
}


.................................................DAY-7.................................................................................................................


QUE.1 inorder Binary search tree on (leet code )

CODE:

#include <iostream>
using namespace std;

// Definition for a binary tree node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// Recursive Inorder Traversal
void inorderTraversal(TreeNode* root) {
    if (root == NULL) return;

    // Traverse the left subtree
    inorderTraversal(root->left);

    // Visit the root node
    cout << root->val << " ";

    // Traverse the right subtree
    inorderTraversal(root->right);
}

int main() {
    // Example Tree:
    //        5
    //       / \
    //      3   7
    //     / \   / \
    //    2   4 6   8

    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(3);
    root->right = new TreeNode(7);
    root->left->left = new TreeNode(2);
    root->left->right = new TreeNode(4);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(8);

    cout << "Inorder Traversal (Recursive): ";
    inorderTraversal(root);  // Output: 2 3 4 5 6 7 8

    return 0;
}

QUE.2:- preorder binary search tree.

CODE:

#include <iostream>
using namespace std;

// Definition for a binary tree node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// Recursive Preorder Traversal
void preorderTraversal(TreeNode* root) {
    if (root == NULL) return;

    // Visit the root node
    cout << root->val << " ";

    // Traverse the left subtree
    preorderTraversal(root->left);

    // Traverse the right subtree
    preorderTraversal(root->right);
}

int main() {
    // Example Tree:
    //        5
    //       / \
    //      3   7
    //     / \   / \
    //    2   4 6   8

    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(3);
    root->right = new TreeNode(7);
    root->left->left = new TreeNode(2);
    root->left->right = new TreeNode(4);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(8);

    cout << "Preorder Traversal (Recursive): ";
    preorderTraversal(root);  // Output: 5 3 2 4 7 6 8

    return 0;
}


QUE.3: Postorder Binary search tree on (LEET CODE).


CODE :

#include <iostream>
using namespace std;

// Definition for a binary tree node
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// Recursive Postorder Traversal
void postorderTraversal(TreeNode* root) {
    if (root == NULL) return;

    // Traverse the left subtree
    postorderTraversal(root->left);

    // Traverse the right subtree
    postorderTraversal(root->right);

    // Visit the root node
    cout << root->val << " ";
}

int main() {
    // Example Tree:
    //        5
    //       / \
    //      3   7
    //     / \   / \
    //    2   4 6   8

    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(3);
    root->right = new TreeNode(7);
    root->left->left = new TreeNode(2);
    root->left->right = new TreeNode(4);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(8);

    cout << "Postorder Traversal (Recursive): ";
    postorderTraversal(root);  // Output: 2 4 3 6 8 7 5

    return 0;
}



















