..................................................DAY-1:.......................................................................................................

QUESTION-1 : WAP on sum of Natural number Upto N.

Code:
#include <iostream>
using namespace std;

int main() 
    {
    int  sum = 0;

    
    // cout << "Enter a positive integer: ";
    // cin >> n;

    int n = 10;
    for (int i = 1; i <= n; i++) 
    {
        sum += i; 
    }

  
    cout << "The sum of natural numbers up to " << n << " is: " << sum << endl;

    return 0;
}

OUTPUT:

   The sum of natural numbers up to 10 is: 55




QUESTION.2- WAP to check Whether a number Prime or Not..

Code.
#include <iostream>
using namespace std;

int main() 
{

    int n = 12;
    bool isPrime = true;

    // Input from the user
    // cout << "Enter a positive integer: ";
    // cin >> n;

    
    if (n <= 1) 
    {
        isPrime = false;
    } else 
    {
       
        for (int i = 2; i * i <= n; i++) 
    {
            if (n % i == 0) 
    {
                isPrime = false;
                break;
            }
        }
    }

    if (isPrime)
    {
        cout << n << " is a prime number." << endl;
    } else {
        cout << n << " is not a prime number." << endl;
    }

    return 0;
}

OUTPUT:

     12 is not a prime number.


QUESTION.3: Print your whole Acedemic Bio data Name , UID , Section Area of interest , Age , Last year CGPA , DOB, Home Town , Aim in Life...

Code.

#include <iostream>
using namespace std;

int main() 
    {
    string name, uid, section, areaOfInterest, dob, homeTown, aimInLife;
    int age;
    float lastYearCGPA;

    // Taking user inputs
    cout << "Enter your name: ";
    getline(cin, name);

    cout << "Enter your UID: ";
    getline(cin, uid);

    cout << "Enter your section: ";
    getline(cin, section);

    cout << "Enter your area of interest: ";
    getline(cin, areaOfInterest);

    cout << "Enter your age: ";
    cin >> age;

    cout << "Enter your last year CGPA: ";
    cin >> lastYearCGPA;

    cin.ignore(); // Clear input buffer

    cout << "Enter your date of birth (DOB): ";
    getline(cin, dob);

    cout << "Enter your hometown: ";
    getline(cin, homeTown);

    cout << "Enter your aim in life: ";
    getline(cin, aimInLife);

    // Using conditional operator to validate inputs
    cout << "\nAcademic Bio Data:\n";
    cout << "Name: " << (!name.empty() ? name : "Not Provided") << endl;
    cout << "UID: " << (!uid.empty() ? uid : "Not Provided") << endl;
    cout << "Section: " << (!section.empty() ? section : "Not Provided") << endl;
    cout << "Area of Interest: " << (!areaOfInterest.empty() ? areaOfInterest : "Not Provided") << endl;
    cout << "Age: " << (age > 0 ? to_string(age) : "Invalid Age") << endl;
    cout << "Last Year CGPA: " << (lastYearCGPA >= 0.0 ? to_string(lastYearCGPA) : "Invalid CGPA") << endl;
    cout << "Date of Birth: " << (!dob.empty() ? dob : "Not Provided") << endl;
    cout << "Home Town: " << (!homeTown.empty() ? homeTown : "Not Provided") << endl;
    cout << "Aim in Life: " << (!aimInLife.empty() ? aimInLife : "Not Provided") << endl;

    return 0;
}

OUTPUT:

Academic Bio Data:
Name: ahatsham
UID: 22BCS10017
Section: iot-630
Area of Interest: CSE
Age: 22
Last Year CGPA: 6.900000
Date of Birth: 3-2-2004
Home Town: gkp
Aim in Life: software engineer


................................................... DAY-2:...............................................................................................................


Q1: Convert Sorted Array to Binary Search Tree

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.


Code:

#include <iostream>
#include <vector>
using namespace std;


struct TreeNode 
    {
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) 
    {
    
    }
};


TreeNode* sortedArrayToBST(vector<int>& nums, int start, int end) 
    {
    
    if (start > end) return nullptr;

    
    int mid = start + (end - start) / 2;

 
    TreeNode* root = new TreeNode(nums[mid]);



    root->left = sortedArrayToBST(nums, start, mid - 1);
    root->right = sortedArrayToBST(nums, mid + 1, end);

    return root;
}


TreeNode* sortedArrayToBST(vector<int>& nums) 
    {
    return sortedArrayToBST(nums, 0, nums.size() - 1);
}


void inOrderTraversal(TreeNode* root) 
    {
    if (!root) return;
    inOrderTraversal(root->left);
    cout << root->val << " ";
    inOrderTraversal(root->right);
}

// Main function
int main() 
    {
    vector<int> nums = {-10, -3, 0, 5, 9};

    TreeNode* root = sortedArrayToBST(nums);

    cout << "In-order Traversal of the BST: ";
    inOrderTraversal(root);
    cout << endl;

    return 0;
}



*/Q2: Valid Sudoku

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition.Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.*/

Code:

// Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;

// Function to check if the board is valid
bool isValidSudoku(vector<vector<char>>& board)
    {
    // Create sets to track seen numbers in rows, columns, and sub-boxes
    vector<unordered_set<char>> rows(9), cols(9), boxes(9);

    for (int i = 0; i < 9; i++) 
    {
        for (int j = 0; j < 9; j++)
    {
            char num = board[i][j];
            if (num == '.') continue; // Skip empty cells
            
            // Calculate the index of the 3x3 sub-box
            int boxIndex = (i / 3) * 3 + (j / 3);

            // Check if the number is already in the current row, column, or sub-box
            if (rows[i].count(num) || cols[j].count(num) || boxes[boxIndex].count(num)) 
    {
                return false; // Invalid board
            }

            // Add the number to the respective row, column, and sub-box sets
            rows[i].insert(num);
            cols[j].insert(num);
            boxes[boxIndex].insert(num);
        }
    }

    return true; // Valid board
}

// Main function to test the implementation
int main() 
    {
    // Example of a valid Sudoku board
    vector<vector<char>> board = {
        {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
        {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
        {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
        {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
        {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
        {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
        {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
        {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
        {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
    };

    if (isValidSudoku(board)) 
    {
        cout << "The Sudoku board is valid.\n";
    } else 
    {
        cout << "The Sudoku board is invalid.\n";
    }

    return 0;
}


Q3: Remove Element

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums..


Code:

#include <iostream>
#include <vector>
using namespace std;

int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0; // Handle edge case of an empty array

    int uniqueIndex = 0; // Pointer for the last unique element's position

    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] != nums[uniqueIndex]) {
            uniqueIndex++;         // Move the uniqueIndex forward
            nums[uniqueIndex] = nums[i]; // Update the position with the new unique element
        }
    }

    return uniqueIndex + 1; // Number of unique elements
}

// Main function to test the implementation
int main() {
    vector<int> nums = {1, 1, 2, 2, 3, 4, 4, 5};

    int uniqueCount = removeDuplicates(nums);

    cout << "Number of unique elements: " << uniqueCount << endl;
    cout << "Modified array: ";
    for (int i = 0; i < uniqueCount; i++) {
        cout << nums[i] << " ";
    }
    cout << endl;

    return 0;
}

  ................ .....................................  DAY-3: ...................................................................................................

/*Q1 . Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.*/

Code:

#include <iostream>
using namespace std;

// Definition for singly-linked list.
struct ListNode
    {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr)
    {
    
    }
};

// Function to add two numbers represented by linked lists
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode* dummyHead = new ListNode(0); // Placeholder for result list
    ListNode* current = dummyHead;        // Pointer to build the result list
    int carry = 0;                        // Initialize carry to 0
    
    // Traverse both linked lists
    while (l1 != nullptr || l2 != nullptr || carry)
    {
        int val1 = (l1 != nullptr) ? l1->val : 0; // Get value from l1 or 0 if null
        int val2 = (l2 != nullptr) ? l2->val : 0; // Get value from l2 or 0 if null
        int sum = val1 + val2 + carry;           // Sum the values and carry
        
        carry = sum / 10;                        // Update carry for the next addition
        current->next = new ListNode(sum % 10); // Create a new node with the ones place
        
        current = current->next;                // Move to the next node
        
        if (l1 != nullptr) l1 = l1->next;       // Move to the next node in l1
        if (l2 != nullptr) l2 = l2->next;       // Move to the next node in l2
    }
    
    return dummyHead->next; // Return the next node of dummyHead (skip placeholder)
}

// Helper function to create a linked list from an array
ListNode* createLinkedList(int arr[], int n) 
    {
    if (n == 0) return nullptr;
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; ++i) 
    {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// Helper function to print a linked list
void printLinkedList(ListNode* head) {
    while (head != nullptr) 
    {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

// Main function
int main() 
    {
    // Input arrays
    int arr1[] = {2, 4, 3}; // Represents the number 342
    int arr2[] = {5, 6, 4}; // Represents the number 465

    // Create linked lists from arrays
    ListNode* l1 = createLinkedList(arr1, 3);
    ListNode* l2 = createLinkedList(arr2, 3);

    // Add the two numbers
    ListNode* result = addTwoNumbers(l1, l2);

    // Print the result
    cout << "Result: ";
    printLinkedList(result); // Output: 7 0 8

    return 0;
}

/*Q2 . Elimination Game
You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:
 Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.
Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.
Keep repeating the steps again, alternating left to right and right to left, until a single number remains.*/

Code:

#include <iostream>
using namespace std;

int eliminationGame(int n) 
    {
    int head = 1;         // First number in the range
    int step = 1;         // Gap between numbers in the current round
    int remaining = n;    // Number of elements left
    bool left = true;     // Direction of elimination
    
    while (remaining > 1) 
    {
        if (left || remaining % 2 == 1) 
    {
           
            head += step;
        }
     
        step *= 2;
       
        remaining /= 2;
       
        left = !left;
    }
    
    return head; 
}

int main() 
    {
    int n = 9; 
    cout << "Last remaining number: " << eliminationGame(n) << endl;
    return 0;
}

/*Q3 . Predict The Winner
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.
 Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1])
which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.
 Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.*/

Code: 

#include <iostream>
#include <vector>
using namespace std;

class Solution 
    {
public:
    bool PredictTheWinner(vector<int>& nums) 
        {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        
        // Base case: Single element in the array
        for (int i = 0; i < n; ++i) 
        {
            dp[i][i] = nums[i];
        }
        
        // Fill the DP table
        for (int len = 2; len <= n; ++len) 
    { // Subarray lengths
            for (int i = 0; i <= n - len; ++i) 
    {
                int j = i + len - 1; // End of the subarray
                dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);
    }
    }
        
      
        return dp[0][n-1] >= 0;
    }
};

// Example usage
int main() 
    {
    Solution solution;
    vector<int> nums = {1, 5, 2};
    cout << (solution.PredictTheWinner(nums) ? "Player 1 can win" : "Player 1 cannot win") << endl;
    return 0;
}


Q4 . Find The Winner Of Circular Game
There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
 The rules of the game are as follows:
 Start at the 1st friend.
Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
The last friend you counted leaves the circle and loses the game.
If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.


Code:

#include <iostream>
#include <vector>
using namespace std;

int findTheWinner(int n, int k)
    {
    vector<int> friends(n);
    for (int i = 0; i < n; ++i)
    {
        friends[i] = i + 1; // Initialize friends 1 to n
    }
    
    int index = 0; // Start from the first friend
    while (friends.size() > 1) {
        // Find the k-th friend to remove
        index = (index + k - 1) % friends.size();
        friends.erase(friends.begin() + index);
    }
    
    return friends[0]; // The last remaining friend
    }

int main() 
    {
    int n = 5, k = 2;
    cout << "Winner: " << findTheWinner(n, k) << endl;
    return 0;
    }


Q5 Minimun  non zero product of an Array Elements
You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times:
 Choose two elements x and y from nums.
Choose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.
For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.
Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.

Code : 

#include <iostream>
#include <cmath>
using namespace std;

const int MOD = 1e9 + 7;

// Function to perform modular exponentiation
long long modExp(long long base, long long exp, long long mod) 
    {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
    }

int minNonZeroProduct(int p)
    {
    long long maxNum = (1LL << p) - 1;        // 2^p - 1
    long long secondMax = maxNum - 1;        // 2^p - 2
    long long count = (1LL << (p - 1)) - 1;  // 2^(p-1) - 1

    // Compute the minimum product modulo 10^9 + 7
    long long result = maxNum % MOD;  // maxNum * (secondMax ^ count) % MOD
    result = (result * modExp(secondMax, count, MOD)) % MOD;

    return result;
    }

int main() 
    {
    int p = 3; // Example input
    cout << "Minimum Non-Zero Product: " << minNonZeroProduct(p) << endl;
    return 0;
    }



....................................DAY-4...........................................................................................


/*1. Fraud Detection in Banking Transactions
A banking institution monitors transactions for potential fraud by analyzing patterns in transaction size, frequency,
and geographical location. The transactions are sorted by suspiciousness score, calculated using a combination of these factors.
High-risk transactions are flagged for immediate review by analysts, requiring a robust and scalable sorting mechanism to handle
millions of records daily.*/


Code:


#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

// Structure to represent a transaction
struct Transaction {
    int id;                 // Unique transaction ID
    double amount;          // Transaction amount
    int frequency;          // Frequency of transactions from this account
    std::string location;   // Transaction location
    double suspiciousScore; // Calculated suspiciousness score

    // Constructor
    Transaction(int id, double amount, int frequency, const std::string& location, double score)
        : id(id), amount(amount), frequency(frequency), location(location), suspiciousScore(score) {}
};

// Function to calculate suspiciousness score (simplified example)
double calculateSuspiciousScore(double amount, int frequency, const std::string& location) {
    double baseScore = amount * 0.5 + frequency * 2.0;
    if (location == "high-risk") { // Assume "high-risk" is a specific location flag
        baseScore += 50.0;
    }
    return baseScore;
}

// Comparator for sorting transactions by suspiciousness score in descending order
bool compareTransactions(const Transaction& t1, const Transaction& t2) {
    return t1.suspiciousScore > t2.suspiciousScore;
}

// Function to flag high-risk transactions
void flagHighRiskTransactions(const std::vector<Transaction>& transactions, double riskThreshold) {
    std::cout << "Flagged High-Risk Transactions:\n";
    for (const auto& transaction : transactions) {
        if (transaction.suspiciousScore >= riskThreshold) {
            std::cout << "Transaction ID: " << transaction.id
                      << ", Suspicious Score: " << transaction.suspiciousScore << "\n";
        }
    }
}

int main() {
    // Sample dataset
    std::vector<Transaction> transactions = {
        Transaction(1, 1000.0, 5, "normal", calculateSuspiciousScore(1000.0, 5, "normal")),
        Transaction(2, 2000.0, 3, "high-risk", calculateSuspiciousScore(2000.0, 3, "high-risk")),
        Transaction(3, 500.0, 8, "normal", calculateSuspiciousScore(500.0, 8, "normal")),
        Transaction(4, 3000.0, 2, "high-risk", calculateSuspiciousScore(3000.0, 2, "high-risk")),
        Transaction(5, 800.0, 6, "normal", calculateSuspiciousScore(800.0, 6, "normal"))
    };

    // Sort transactions by suspiciousness score
    std::sort(transactions.begin(), transactions.end(), compareTransactions);

    // Output sorted transactions
    std::cout << "Sorted Transactions by Suspiciousness Score:\n";
    for (const auto& transaction : transactions) {
        std::cout << "Transaction ID: " << transaction.id
                  << ", Amount: $" << transaction.amount
                  << ", Frequency: " << transaction.frequency
                  << ", Location: " << transaction.location
                  << ", Suspicious Score: " << transaction.suspiciousScore << "\n";
    }

    // Set a risk threshold for flagging high-risk transactions
    double riskThreshold = 100.0;
    std::cout << "\n";
    flagHighRiskTransactions(transactions, riskThreshold);

    return 0;
}


OUTPUT::--

Sorted Transactions by Suspiciousness Score:
Transaction ID: 4, Amount: $3000, Frequency: 2, Location: high-risk, Suspicious Score: 155
Transaction ID: 2, Amount: $2000, Frequency: 3, Location: high-risk, Suspicious Score: 156
Transaction ID: 1, Amount: $1000, Frequency: 5, Location: normal, Suspicious Score: 60
Transaction ID: 5, Amount: $800, Frequency: 6, Location: normal, Suspicious Score: 56
Transaction ID: 3, Amount: $500, Frequency: 8, Location: normal, Suspicious Score: 56

Flagged High-Risk Transactions:
Transaction ID: 4, Suspicious Score: 155
Transaction ID: 2, Suspicious Score: 156






*/    2. Stock Market Data Analysis
A financial technology company needs to process real-time stock market data consisting of millions of trades every minute.
Each trade record includes the timestamp, stock symbol, trade price, and trade volume. To identify patterns and generate analytics,
the trades must be sorted by timestamp. For deeper insights, the company also requires sorting by stock symbol and grouping by trading volume trends.
Handling this large-scale data efficiently is crucial for providing timely analytics to clients.*/


Code::---


#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <map>

// Structure to represent a stock trade record
struct TradeRecord {
    long long timestamp;  // Timestamp of the trade (e.g., Unix timestamp)
    std::string symbol;   // Stock symbol (e.g., AAPL, MSFT)
    double price;         // Trade price
    int volume;           // Trade volume

    // Constructor
    TradeRecord(long long t, const std::string& s, double p, int v)
        : timestamp(t), symbol(s), price(p), volume(v) {}
};

// Comparator for sorting by timestamp
bool sortByTimestamp(const TradeRecord& a, const TradeRecord& b) {
    return a.timestamp < b.timestamp;
}

// Comparator for sorting by stock symbol
bool sortBySymbol(const TradeRecord& a, const TradeRecord& b) {
    return a.symbol < b.symbol;
}

// Group trades by volume trends
std::map<std::string, std::vector<TradeRecord>> groupByVolumeTrends(const std::vector<TradeRecord>& trades) {
    std::map<std::string, std::vector<TradeRecord>> groupedTrades;

    for (const auto& trade : trades) {
        if (trade.volume < 100) {
            groupedTrades["Low Volume"].push_back(trade);
        } else if (trade.volume >= 100 && trade.volume < 1000) {
            groupedTrades["Medium Volume"].push_back(trade);
        } else {
            groupedTrades["High Volume"].push_back(trade);
        }
    }

    return groupedTrades;
}

int main() {
    // Sample dataset
    std::vector<TradeRecord> trades = {
        TradeRecord(1672531200, "AAPL", 145.30, 500),
        TradeRecord(1672531300, "MSFT", 310.20, 1200),
        TradeRecord(1672531400, "GOOGL", 2800.15, 50),
        TradeRecord(1672531250, "AAPL", 145.50, 800),
        TradeRecord(1672531350, "MSFT", 310.25, 300),
        TradeRecord(1672531500, "GOOGL", 2810.00, 1200)
    };

    // Sort trades by timestamp
    std::sort(trades.begin(), trades.end(), sortByTimestamp);

    // Display trades sorted by timestamp
    std::cout << "Trades Sorted by Timestamp:\n";
    for (const auto& trade : trades) {
        std::cout << "Timestamp: " << trade.timestamp
                  << ", Symbol: " << trade.symbol
                  << ", Price: $" << trade.price
                  << ", Volume: " << trade.volume << "\n";
    }

    // Sort trades by stock symbol
    std::sort(trades.begin(), trades.end(), sortBySymbol);

    // Display trades sorted by stock symbol
    std::cout << "\nTrades Sorted by Stock Symbol:\n";
    for (const auto& trade : trades) {
        std::cout << "Timestamp: " << trade.timestamp
                  << ", Symbol: " << trade.symbol
                  << ", Price: $" << trade.price
                  << ", Volume: " << trade.volume << "\n";
    }

    // Group trades by volume trends
    std::map<std::string, std::vector<TradeRecord>> groupedTrades = groupByVolumeTrends(trades);

    // Display trades grouped by volume trends
    std::cout << "\nTrades Grouped by Volume Trends:\n";
    for (const auto& group : groupedTrades) {
        std::cout << group.first << ":\n";
        for (const auto& trade : group.second) {
            std::cout << "  Timestamp: " << trade.timestamp
                      << ", Symbol: " << trade.symbol
                      << ", Price: $" << trade.price
                      << ", Volume: " << trade.volume << "\n";
        }
    }

    return 0;
}


OUTPUT:

Trades Sorted by Timestamp:
Timestamp: 1672531200, Symbol: AAPL, Price: $145.3, Volume: 500
Timestamp: 1672531250, Symbol: AAPL, Price: $145.5, Volume: 800
Timestamp: 1672531300, Symbol: MSFT, Price: $310.2, Volume: 1200
Timestamp: 1672531350, Symbol: MSFT, Price: $310.25, Volume: 300
Timestamp: 1672531400, Symbol: GOOGL, Price: $2800.15, Volume: 50
Timestamp: 1672531500, Symbol: GOOGL, Price: $2810, Volume: 1200

Trades Sorted by Stock Symbol:
Timestamp: 1672531200, Symbol: AAPL, Price: $145.3, Volume: 500
Timestamp: 1672531250, Symbol: AAPL, Price: $145.5, Volume: 800
Timestamp: 1672531400, Symbol: GOOGL, Price: $2800.15, Volume: 50
Timestamp: 1672531500, Symbol: GOOGL, Price: $2810, Volume: 1200
Timestamp: 1672531300, Symbol: MSFT, Price: $310.2, Volume: 1200
Timestamp: 1672531350, Symbol: MSFT, Price: $310.25, Volume: 300

Trades Grouped by Volume Trends:
Low Volume:
  Timestamp: 1672531400, Symbol: GOOGL, Price: $2800.15, Volume: 50
Medium Volume:
  Timestamp: 1672531200, Symbol: AAPL, Price: $145.3, Volume: 500
  Timestamp: 1672531250, Symbol: AAPL, Price: $145.5, Volume: 800
  Timestamp: 1672531350, Symbol: MSFT, Price: $310.25, Volume: 300
High Volume:
  Timestamp: 1672531300, Symbol: MSFT, Price: $310.2, Volume: 1200
  Timestamp: 1672531500, Symbol: GOOGL, Price: $2810, Volume: 1200






/* 
3. Video Streaming Platform Recommendation System
A video streaming platform generates recommendations for users based on the popularity of movies and TV shows. 
Each item in the catalog has attributes like total views,
user ratings, and release year. The system must sort the catalog to prioritize trending content by combining popularity and recency.
Furthermore, personalized recommendations require sorting by relevance to each user's viewing history, making the sorting process dynamic and computationally intensive.*/


CODE::--


#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>

// Structure to represent a catalog item
struct CatalogItem {
    std::string title;   // Title of the movie/TV show
    int totalViews;      // Total number of views
    double userRating;   // Average user rating (out of 5)
    int releaseYear;     // Release year
    double relevance;    // User-specific relevance score

    // Constructor
    CatalogItem(const std::string& t, int v, double r, int y, double rel)
        : title(t), totalViews(v), userRating(r), releaseYear(y), relevance(rel) {}
};

// Comparator for trending content (popularity + recency)
bool sortByTrending(const CatalogItem& a, const CatalogItem& b) {
    // Combine popularity (views) and recency (release year with exponential decay)
    double scoreA = a.totalViews * 0.7 + (2024 - a.releaseYear) * 0.3; // Example weighting
    double scoreB = b.totalViews * 0.7 + (2024 - b.releaseYear) * 0.3;
    return scoreA > scoreB;
}

// Comparator for personalized recommendations (relevance)
bool sortByRelevance(const CatalogItem& a, const CatalogItem& b) {
    return a.relevance > b.relevance;
}

int main() {
    // Sample dataset
    std::vector<CatalogItem> catalog = {
        CatalogItem("Movie A", 100000, 4.5, 2020, 0.9),
        CatalogItem("TV Show B", 150000, 4.8, 2021, 0.7),
        CatalogItem("Movie C", 80000, 4.2, 2018, 0.85),
        CatalogItem("TV Show D", 120000, 4.7, 2023, 0.95),
        CatalogItem("Movie E", 50000, 3.9, 2015, 0.6)
    };

    // Sort by trending content
    std::sort(catalog.begin(), catalog.end(), sortByTrending);

    // Display catalog sorted by trending content
    std::cout << "Catalog Sorted by Trending Content:\n";
    for (const auto& item : catalog) {
        std::cout << "Title: " << item.title
                  << ", Total Views: " << item.totalViews
                  << ", User Rating: " << item.userRating
                  << ", Release Year: " << item.releaseYear << "\n";
    }


    std::sort(catalog.begin(), catalog.end(), sortByRelevance);

  
    std::cout << "\nCatalog Sorted by Personalized Relevance:\n";
    for (const auto& item : catalog) {
        std::cout << "Title: " << item.title
                  << ", Relevance: " << item.relevance
                  << ", Total Views: " << item.totalViews
                  << ", User Rating: " << item.userRating
                  << ", Release Year: " << item.releaseYear << "\n";
    }

    return 0;
}


OUTPUT:

Catalog Sorted by Trending Content:
Title: TV Show D, Total Views: 120000, User Rating: 4.7, Release Year: 2023
Title: TV Show B, Total Views: 150000, User Rating: 4.8, Release Year: 2021
Title: Movie A, Total Views: 100000, User Rating: 4.5, Release Year: 2020
Title: Movie C, Total Views: 80000, User Rating: 4.2, Release Year: 2018
Title: Movie E, Total Views: 50000, User Rating: 3.9, Release Year: 2015

Catalog Sorted by Personalized Relevance:
Title: TV Show D, Relevance: 0.95, Total Views: 120000, User Rating: 4.7, Release Year: 2023
Title: Movie A, Relevance: 0.9, Total Views: 100000, User Rating: 4.5, Release Year: 2020
Title: Movie C, Relevance: 0.85, Total Views: 80000, User Rating: 4.2, Release Year: 2018
Title: TV Show B, Relevance: 0.7, Total Views: 150000, User Rating: 4.8, Release Year: 2021
Title: Movie E, Relevance: 0.6, Total Views: 50000, User Rating: 3.9, Release Year: 2015


/*
4. Hospital Resource Allocation
A hospital management system needs to sort incoming patients in the emergency department based on triage priority, severity of condition, and arrival time. 
The sorted list determines the order in which patients are seen by medical professionals. Additionally, during peak times, the system must dynamically adjust the sorting as new patients arrive, 
ensuring that life-threatening cases are prioritized while maintaining fairness*/


CODE::--

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

// Structure to represent a patient
struct Patient {
    std::string name;
    int triagePriority; // Higher value indicates higher priority
    int severity;       // Severity of condition (scale: 1-10, higher is more severe)
    int arrivalTime;    // Lower value means earlier arrival time

    // Constructor
    Patient(const std::string& n, int tp, int s, int at)
        : name(n), triagePriority(tp), severity(s), arrivalTime(at) {}
};

// Comparator to sort patients dynamically
bool sortByPriority(const Patient& a, const Patient& b) {
    // Primary: Triage priority (higher is better)
    if (a.triagePriority != b.triagePriority)
        return a.triagePriority > b.triagePriority;

    // Secondary: Severity of condition (higher is more urgent)
    if (a.severity != b.severity)
        return a.severity > b.severity;

    // Tertiary: Arrival time (earlier is better)
    return a.arrivalTime < b.arrivalTime;
}

class Hospital {
private:
    std::vector<Patient> patients;

public:
    // Add a new patient to the list
    void addPatient(const std::string& name, int triagePriority, int severity, int arrivalTime) {
        patients.push_back(Patient(name, triagePriority, severity, arrivalTime));
        // Sort the patients after adding a new one
        std::sort(patients.begin(), patients.end(), sortByPriority);
    }

    // Display the list of patients (sorted)
    void displayPatients() {
        std::cout << "\nSorted Patient List (by Priority):\n";
        for (const auto& patient : patients) {
            std::cout << "Name: " << patient.name
                      << ", Triage Priority: " << patient.triagePriority
                      << ", Severity: " << patient.severity
                      << ", Arrival Time: " << patient.arrivalTime << "\n";
        }
    }

    // Remove a patient after they have been seen
    void removePatient(const std::string& name) {
        auto it = std::find_if(patients.begin(), patients.end(),
                               [&name](const Patient& p) { return p.name == name; });

        if (it != patients.end()) {
            patients.erase(it);
            std::cout << "Patient " << name << " has been removed from the queue.\n";
        } else {
            std::cout << "Patient not found.\n";
        }
    }
};

int main() {
    Hospital hospital;

    // Simulating patient arrivals
    hospital.addPatient("John Doe", 3, 8, 10);  // Triage: 3, Severity: 8, Arrival: 10
    hospital.addPatient("Alice Smith", 5, 9, 12);  // Triage: 5, Severity: 9, Arrival: 12
    hospital.addPatient("Bob Brown", 5, 8, 8);   // Triage: 5, Severity: 8, Arrival: 8
    hospital.addPatient("Eve White", 4, 10, 11);  // Triage: 4, Severity: 10, Arrival: 11
    hospital.addPatient("Charlie Black", 2, 5, 9); // Triage: 2, Severity: 5, Arrival: 9

    // Display the sorted patient list
    hospital.displayPatients();

    // Removing a patient after they are seen
    hospital.removePatient("Alice Smith");

    // Display the updated patient list
    hospital.displayPatients();

    return 0;
}


OUTPUT::-


Sorted Patient List (by Priority):
Name: Alice Smith, Triage Priority: 5, Severity: 9, Arrival Time: 12
Name: Bob Brown, Triage Priority: 5, Severity: 8, Arrival Time: 8
Name: Eve White, Triage Priority: 4, Severity: 10, Arrival Time: 11
Name: John Doe, Triage Priority: 3, Severity: 8, Arrival Time: 10
Name: Charlie Black, Triage Priority: 2, Severity: 5, Arrival Time: 9

Patient Alice Smith has been removed from the queue.

Sorted Patient List (by Priority):
Name: Bob Brown, Triage Priority: 5, Severity: 8, Arrival Time: 8
Name: Eve White, Triage Priority: 4, Severity: 10, Arrival Time: 11
Name: John Doe, Triage Priority: 3, Severity: 8, Arrival Time: 10
Name: Charlie Black, Triage Priority: 2, Severity: 5, Arrival Time: 9


/*
5. Scheduling Ads for a Social Media Platform
A social media platform runs advertisements for multiple advertisers, each targeting specific user demographics.
Ads are prioritized based on factors like bid amount, engagement rates, and the remaining budget. To maximize revenue and user satisfaction,
the platform must sort and schedule ads in real-time for millions of users while balancing competing priorities. Efficient sorting directly impacts ad visibility and revenue generation.*/


CODE::--

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

// Structure to represent an ad
struct Ad {
    std::string advertiser;
    int bidAmount;        // Amount the advertiser is willing to pay
    double engagementRate; // Engagement rate (0-1)
    double remainingBudget; // Remaining budget for the ad campaign

    // Constructor
    Ad(const std::string& adName, int bid, double engagement, double budget)
        : advertiser(adName), bidAmount(bid), engagementRate(engagement), remainingBudget(budget) {}
};

// Comparator to sort ads dynamically based on bid amount, engagement rate, and remaining budget
bool sortAdsByPriority(const Ad& a, const Ad& b) {
    // Primary: Bid amount (higher is better)
    if (a.bidAmount != b.bidAmount)
        return a.bidAmount > b.bidAmount;

    // Secondary: Engagement rate (higher is better)
    if (a.engagementRate != b.engagementRate)
        return a.engagementRate > b.engagementRate;

    // Tertiary: Remaining budget (higher is better)
    return a.remainingBudget > b.remainingBudget;
}

class AdPlatform {
private:
    std::vector<Ad> ads;

public:
    // Add a new ad to the system
    void addAd(const std::string& advertiser, int bidAmount, double engagementRate, double remainingBudget) {
        ads.push_back(Ad(advertiser, bidAmount, engagementRate, remainingBudget));
        // Sort the ads immediately after adding a new one
        std::sort(ads.begin(), ads.end(), sortAdsByPriority);
    }

    // Display the sorted ad list
    void displayAds() {
        std::cout << "\nSorted Ads (by Priority):\n";
        for (const auto& ad : ads) {
            std::cout << "Advertiser: " << ad.advertiser
                      << ", Bid Amount: $" << ad.bidAmount
                      << ", Engagement Rate: " << ad.engagementRate
                      << ", Remaining Budget: $" << ad.remainingBudget << "\n";
        }
    }

    // Remove an ad after its campaign has ended or it has been displayed
    void removeAd(const std::string& advertiser) {
        auto it = std::find_if(ads.begin(), ads.end(),
                               [&advertiser](const Ad& ad) { return ad.advertiser == advertiser; });

        if (it != ads.end()) {
            ads.erase(it);
            std::cout << "Ad from " << advertiser << " has been removed from the platform.\n";
        } else {
            std::cout << "Ad not found.\n";
        }
    }
};

int main() {
    AdPlatform platform;

    // Simulating ad submissions
    platform.addAd("Brand A", 500, 0.85, 1000); // High bid, decent engagement, high budget
    platform.addAd("Brand B", 600, 0.90, 500);  // Higher bid, higher engagement, lower budget
    platform.addAd("Brand C", 450, 0.80, 1500); // Medium bid, lower engagement, higher budget
    platform.addAd("Brand D", 700, 0.75, 1200); // Very high bid, moderate engagement, moderate budget
    platform.addAd("Brand E", 550, 0.88, 800);  // Moderate bid, very high engagement, moderate budget

    // Display the sorted list of ads
    platform.displayAds();

    // Removing an ad after its campaign ends
    platform.removeAd("Brand B");

    // Display the updated list of ads
    platform.displayAds();

    return 0;
}


OUTPUT::--

Sorted Ads (by Priority):
Advertiser: Brand D, Bid Amount: $700, Engagement Rate: 0.75, Remaining Budget: $1200
Advertiser: Brand B, Bid Amount: $600, Engagement Rate: 0.90, Remaining Budget: $500
Advertiser: Brand E, Bid Amount: $550, Engagement Rate: 0.88, Remaining Budget: $800
Advertiser: Brand A, Bid Amount: $500, Engagement Rate: 0.85, Remaining Budget: $1000
Advertiser: Brand C, Bid Amount: $450, Engagement Rate: 0.80, Remaining Budget: $1500

Ad from Brand B has been removed from the platform.

Sorted Ads (by Priority):
Advertiser: Brand D, Bid Amount: $700, Engagement Rate: 0.75, Remaining Budget: $1200
Advertiser: Brand E, Bid Amount: $550, Engagement Rate: 0.88, Remaining Budget: $800
Advertiser: Brand A, Bid Amount: $500, Engagement Rate: 0.85, Remaining Budget: $1000
Advertiser: Brand C, Bid Amount: $450, Engagement Rate: 0.80, Remaining Budget: $1500












