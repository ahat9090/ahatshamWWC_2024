..................................................DAY-1:.......................................................................................................

QUESTION-1 : WAP on sum of Natural number Upto N.

Code:
#include <iostream>
using namespace std;

int main() 
    {
    int  sum = 0;

    
    // cout << "Enter a positive integer: ";
    // cin >> n;

    int n = 10;
    for (int i = 1; i <= n; i++) 
    {
        sum += i; 
    }

  
    cout << "The sum of natural numbers up to " << n << " is: " << sum << endl;

    return 0;
}

OUTPUT:

   The sum of natural numbers up to 10 is: 55




QUESTION.2- WAP to check Whether a number Prime or Not..

Code.
#include <iostream>
using namespace std;

int main() 
{

    int n = 12;
    bool isPrime = true;

    // Input from the user
    // cout << "Enter a positive integer: ";
    // cin >> n;

    
    if (n <= 1) 
    {
        isPrime = false;
    } else 
    {
       
        for (int i = 2; i * i <= n; i++) 
    {
            if (n % i == 0) 
    {
                isPrime = false;
                break;
            }
        }
    }

    if (isPrime)
    {
        cout << n << " is a prime number." << endl;
    } else {
        cout << n << " is not a prime number." << endl;
    }

    return 0;
}

OUTPUT:

     12 is not a prime number.


QUESTION.3: Print your whole Acedemic Bio data Name , UID , Section Area of interest , Age , Last year CGPA , DOB, Home Town , Aim in Life...

Code.

#include <iostream>
using namespace std;

int main() 
    {
    string name, uid, section, areaOfInterest, dob, homeTown, aimInLife;
    int age;
    float lastYearCGPA;

    // Taking user inputs
    cout << "Enter your name: ";
    getline(cin, name);

    cout << "Enter your UID: ";
    getline(cin, uid);

    cout << "Enter your section: ";
    getline(cin, section);

    cout << "Enter your area of interest: ";
    getline(cin, areaOfInterest);

    cout << "Enter your age: ";
    cin >> age;

    cout << "Enter your last year CGPA: ";
    cin >> lastYearCGPA;

    cin.ignore(); // Clear input buffer

    cout << "Enter your date of birth (DOB): ";
    getline(cin, dob);

    cout << "Enter your hometown: ";
    getline(cin, homeTown);

    cout << "Enter your aim in life: ";
    getline(cin, aimInLife);

    // Using conditional operator to validate inputs
    cout << "\nAcademic Bio Data:\n";
    cout << "Name: " << (!name.empty() ? name : "Not Provided") << endl;
    cout << "UID: " << (!uid.empty() ? uid : "Not Provided") << endl;
    cout << "Section: " << (!section.empty() ? section : "Not Provided") << endl;
    cout << "Area of Interest: " << (!areaOfInterest.empty() ? areaOfInterest : "Not Provided") << endl;
    cout << "Age: " << (age > 0 ? to_string(age) : "Invalid Age") << endl;
    cout << "Last Year CGPA: " << (lastYearCGPA >= 0.0 ? to_string(lastYearCGPA) : "Invalid CGPA") << endl;
    cout << "Date of Birth: " << (!dob.empty() ? dob : "Not Provided") << endl;
    cout << "Home Town: " << (!homeTown.empty() ? homeTown : "Not Provided") << endl;
    cout << "Aim in Life: " << (!aimInLife.empty() ? aimInLife : "Not Provided") << endl;

    return 0;
}

OUTPUT:

Academic Bio Data:
Name: ahatsham
UID: 22BCS10017
Section: iot-630
Area of Interest: CSE
Age: 22
Last Year CGPA: 6.900000
Date of Birth: 3-2-2004
Home Town: gkp
Aim in Life: software engineer


................................................... DAY-2:...............................................................................................................


Q1: Convert Sorted Array to Binary Search Tree

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.


Code:

#include <iostream>
#include <vector>
using namespace std;


struct TreeNode 
    {
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) 
    {
    
    }
};


TreeNode* sortedArrayToBST(vector<int>& nums, int start, int end) 
    {
    
    if (start > end) return nullptr;

    
    int mid = start + (end - start) / 2;

 
    TreeNode* root = new TreeNode(nums[mid]);



    root->left = sortedArrayToBST(nums, start, mid - 1);
    root->right = sortedArrayToBST(nums, mid + 1, end);

    return root;
}


TreeNode* sortedArrayToBST(vector<int>& nums) 
    {
    return sortedArrayToBST(nums, 0, nums.size() - 1);
}


void inOrderTraversal(TreeNode* root) 
    {
    if (!root) return;
    inOrderTraversal(root->left);
    cout << root->val << " ";
    inOrderTraversal(root->right);
}

// Main function
int main() 
    {
    vector<int> nums = {-10, -3, 0, 5, 9};

    TreeNode* root = sortedArrayToBST(nums);

    cout << "In-order Traversal of the BST: ";
    inOrderTraversal(root);
    cout << endl;

    return 0;
}



*/Q2: Valid Sudoku

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition.Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.*/

Code:

// Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;

// Function to check if the board is valid
bool isValidSudoku(vector<vector<char>>& board)
    {
    // Create sets to track seen numbers in rows, columns, and sub-boxes
    vector<unordered_set<char>> rows(9), cols(9), boxes(9);

    for (int i = 0; i < 9; i++) 
    {
        for (int j = 0; j < 9; j++)
    {
            char num = board[i][j];
            if (num == '.') continue; // Skip empty cells
            
            // Calculate the index of the 3x3 sub-box
            int boxIndex = (i / 3) * 3 + (j / 3);

            // Check if the number is already in the current row, column, or sub-box
            if (rows[i].count(num) || cols[j].count(num) || boxes[boxIndex].count(num)) 
    {
                return false; // Invalid board
            }

            // Add the number to the respective row, column, and sub-box sets
            rows[i].insert(num);
            cols[j].insert(num);
            boxes[boxIndex].insert(num);
        }
    }

    return true; // Valid board
}

// Main function to test the implementation
int main() 
    {
    // Example of a valid Sudoku board
    vector<vector<char>> board = {
        {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
        {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
        {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
        {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
        {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
        {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
        {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
        {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
        {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
    };

    if (isValidSudoku(board)) 
    {
        cout << "The Sudoku board is valid.\n";
    } else 
    {
        cout << "The Sudoku board is invalid.\n";
    }

    return 0;
}


Q3: Remove Element

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums..


Code:

#include <iostream>
#include <vector>
using namespace std;

int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0; // Handle edge case of an empty array

    int uniqueIndex = 0; // Pointer for the last unique element's position

    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] != nums[uniqueIndex]) {
            uniqueIndex++;         // Move the uniqueIndex forward
            nums[uniqueIndex] = nums[i]; // Update the position with the new unique element
        }
    }

    return uniqueIndex + 1; // Number of unique elements
}

// Main function to test the implementation
int main() {
    vector<int> nums = {1, 1, 2, 2, 3, 4, 4, 5};

    int uniqueCount = removeDuplicates(nums);

    cout << "Number of unique elements: " << uniqueCount << endl;
    cout << "Modified array: ";
    for (int i = 0; i < uniqueCount; i++) {
        cout << nums[i] << " ";
    }
    cout << endl;

    return 0;
}

  ................ .....................................  DAY-3: ...................................................................................................

/*Q1 . Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.*/

Code:

#include <iostream>
using namespace std;

// Definition for singly-linked list.
struct ListNode
    {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr)
    {
    
    }
};

// Function to add two numbers represented by linked lists
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode* dummyHead = new ListNode(0); // Placeholder for result list
    ListNode* current = dummyHead;        // Pointer to build the result list
    int carry = 0;                        // Initialize carry to 0
    
    // Traverse both linked lists
    while (l1 != nullptr || l2 != nullptr || carry)
    {
        int val1 = (l1 != nullptr) ? l1->val : 0; // Get value from l1 or 0 if null
        int val2 = (l2 != nullptr) ? l2->val : 0; // Get value from l2 or 0 if null
        int sum = val1 + val2 + carry;           // Sum the values and carry
        
        carry = sum / 10;                        // Update carry for the next addition
        current->next = new ListNode(sum % 10); // Create a new node with the ones place
        
        current = current->next;                // Move to the next node
        
        if (l1 != nullptr) l1 = l1->next;       // Move to the next node in l1
        if (l2 != nullptr) l2 = l2->next;       // Move to the next node in l2
    }
    
    return dummyHead->next; // Return the next node of dummyHead (skip placeholder)
}

// Helper function to create a linked list from an array
ListNode* createLinkedList(int arr[], int n) 
    {
    if (n == 0) return nullptr;
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (int i = 1; i < n; ++i) 
    {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// Helper function to print a linked list
void printLinkedList(ListNode* head) {
    while (head != nullptr) 
    {
        cout << head->val << " ";
        head = head->next;
    }
    cout << endl;
}

// Main function
int main() 
    {
    // Input arrays
    int arr1[] = {2, 4, 3}; // Represents the number 342
    int arr2[] = {5, 6, 4}; // Represents the number 465

    // Create linked lists from arrays
    ListNode* l1 = createLinkedList(arr1, 3);
    ListNode* l2 = createLinkedList(arr2, 3);

    // Add the two numbers
    ListNode* result = addTwoNumbers(l1, l2);

    // Print the result
    cout << "Result: ";
    printLinkedList(result); // Output: 7 0 8

    return 0;
}

/*Q2 . Elimination Game
You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:
 Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.
Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.
Keep repeating the steps again, alternating left to right and right to left, until a single number remains.*/

Code:

#include <iostream>
using namespace std;

int eliminationGame(int n) 
    {
    int head = 1;         // First number in the range
    int step = 1;         // Gap between numbers in the current round
    int remaining = n;    // Number of elements left
    bool left = true;     // Direction of elimination
    
    while (remaining > 1) 
    {
        if (left || remaining % 2 == 1) 
    {
           
            head += step;
        }
     
        step *= 2;
       
        remaining /= 2;
       
        left = !left;
    }
    
    return head; 
}

int main() 
    {
    int n = 9; 
    cout << "Last remaining number: " << eliminationGame(n) << endl;
    return 0;
}

/*Q3 . Predict The Winner
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.
 Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1])
which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.
 Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.*/

Code: 

#include <iostream>
#include <vector>
using namespace std;

class Solution 
    {
public:
    bool PredictTheWinner(vector<int>& nums) 
        {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        
        // Base case: Single element in the array
        for (int i = 0; i < n; ++i) 
        {
            dp[i][i] = nums[i];
        }
        
        // Fill the DP table
        for (int len = 2; len <= n; ++len) 
    { // Subarray lengths
            for (int i = 0; i <= n - len; ++i) 
    {
                int j = i + len - 1; // End of the subarray
                dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);
    }
    }
        
      
        return dp[0][n-1] >= 0;
    }
};

// Example usage
int main() 
    {
    Solution solution;
    vector<int> nums = {1, 5, 2};
    cout << (solution.PredictTheWinner(nums) ? "Player 1 can win" : "Player 1 cannot win") << endl;
    return 0;
}


Q4 . Find The Winner Of Circular Game
There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
 The rules of the game are as follows:
 Start at the 1st friend.
Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
The last friend you counted leaves the circle and loses the game.
If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.


Code:

#include <iostream>
#include <vector>
using namespace std;

int findTheWinner(int n, int k)
    {
    vector<int> friends(n);
    for (int i = 0; i < n; ++i)
    {
        friends[i] = i + 1; // Initialize friends 1 to n
    }
    
    int index = 0; // Start from the first friend
    while (friends.size() > 1) {
        // Find the k-th friend to remove
        index = (index + k - 1) % friends.size();
        friends.erase(friends.begin() + index);
    }
    
    return friends[0]; // The last remaining friend
    }

int main() 
    {
    int n = 5, k = 2;
    cout << "Winner: " << findTheWinner(n, k) << endl;
    return 0;
    }


Q5 Minimun  non zero product of an Array Elements
You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times:
 Choose two elements x and y from nums.
Choose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.
For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.
Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.

Code : 

#include <iostream>
#include <cmath>
using namespace std;

const int MOD = 1e9 + 7;

// Function to perform modular exponentiation
long long modExp(long long base, long long exp, long long mod) 
    {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
    }

int minNonZeroProduct(int p)
    {
    long long maxNum = (1LL << p) - 1;        // 2^p - 1
    long long secondMax = maxNum - 1;        // 2^p - 2
    long long count = (1LL << (p - 1)) - 1;  // 2^(p-1) - 1

    // Compute the minimum product modulo 10^9 + 7
    long long result = maxNum % MOD;  // maxNum * (secondMax ^ count) % MOD
    result = (result * modExp(secondMax, count, MOD)) % MOD;

    return result;
    }

int main() 
    {
    int p = 3; // Example input
    cout << "Minimum Non-Zero Product: " << minNonZeroProduct(p) << endl;
    return 0;
    }













